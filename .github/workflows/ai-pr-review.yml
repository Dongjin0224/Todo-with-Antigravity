name: AI PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled]
    branches: ["main"]
  workflow_dispatch:
    inputs:
      pull_number:
        description: "Review target PR number"
        required: true
        type: string

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  review:
    if: ${{ github.event_name == 'workflow_dispatch' || (!github.event.pull_request.draft && contains(github.event.pull_request.labels.*.name, 'ai-review')) }}
    runs-on: ubuntu-latest

    steps:
      - name: Generate AI review comment
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || secrets.OPENAI_KEY }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4.1-mini' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const marker = "<!-- ai-pr-review -->";
            const { owner, repo } = context.repo;
            const pull_number = context.eventName === "workflow_dispatch"
              ? Number(context.payload.inputs?.pull_number)
              : Number(context.payload.pull_request?.number);

            if (!Number.isInteger(pull_number) || pull_number <= 0) {
              core.setFailed("Invalid pull_number. Provide a valid PR number in workflow_dispatch input.");
              return;
            }

            if (!process.env.OPENAI_API_KEY) {
              core.setFailed("Missing OPENAI_API_KEY secret.");
              return;
            }

            const pr = await github.rest.pulls.get({ owner, repo, pull_number });
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const diffChunks = files
              .filter((f) => Boolean(f.patch))
              .map((f) => `### ${f.filename}\n\`\`\`diff\n${f.patch}\n\`\`\``);

            if (diffChunks.length === 0) {
              core.info("No patch content to review.");
              return;
            }

            const MAX_DIFF_CHARS = 120000;
            const MAX_INLINE_FINDINGS = 10;
            const diffText = diffChunks.join("\n\n").slice(0, MAX_DIFF_CHARS);

            const severityRank = { critical: 0, major: 1, minor: 2 };

            const extractReviewText = (payload) => {
              if (!payload || typeof payload !== "object") return "";
              if (typeof payload.output_text === "string" && payload.output_text.trim()) {
                return payload.output_text.trim();
              }

              const fromOutput = (payload.output || [])
                .flatMap((item) => item.content || [])
                .map((part) => {
                  if (typeof part?.text === "string") return part.text;
                  if (typeof part?.content === "string") return part.content;
                  return "";
                })
                .filter(Boolean)
                .join("\n")
                .trim();
              if (fromOutput) return fromOutput;

              const fromMessage = (payload.choices || [])
                .map((choice) => {
                  const c = choice?.message?.content;
                  if (typeof c === "string") return c;
                  if (Array.isArray(c)) {
                    return c
                      .map((p) => (typeof p?.text === "string" ? p.text : ""))
                      .filter(Boolean)
                      .join("\n");
                  }
                  return "";
                })
                .filter(Boolean)
                .join("\n")
                .trim();
              return fromMessage;
            };

            const extractJsonCandidate = (text) => {
              const raw = (text || "").trim();
              if (!raw) return "";

              const fenced = raw.match(/```(?:json)?\s*([\s\S]*?)```/i);
              if (fenced?.[1]) return fenced[1].trim();

              const firstBrace = raw.indexOf("{");
              const lastBrace = raw.lastIndexOf("}");
              if (firstBrace !== -1 && lastBrace !== -1 && firstBrace < lastBrace) {
                return raw.slice(firstBrace, lastBrace + 1);
              }
              return raw;
            };

            const parseReviewJson = (text) => {
              try {
                const parsed = JSON.parse(extractJsonCandidate(text));
                const findings = Array.isArray(parsed?.findings) ? parsed.findings : [];
                const normalizedFindings = findings
                  .map((f) => {
                    const severity = String(f?.severity || "").toLowerCase();
                    return {
                      severity: severityRank[severity] !== undefined ? severity : "minor",
                      file: typeof f?.file === "string" ? f.file.trim() : "",
                      line: Number.isFinite(Number(f?.line)) ? Number(f.line) : null,
                      summary: typeof f?.summary === "string" ? f.summary.trim() : "",
                      impact: typeof f?.impact === "string" ? f.impact.trim() : "",
                      evidence: typeof f?.evidence === "string" ? f.evidence.trim() : "",
                      suggestion: typeof f?.suggestion === "string" ? f.suggestion.trim() : ""
                    };
                  })
                  .filter((f) => f.summary);

                const toStringArray = (v) =>
                  Array.isArray(v) ? v.map((x) => String(x || "").trim()).filter(Boolean) : [];

                return {
                  findings: normalizedFindings.sort(
                    (a, b) => (severityRank[a.severity] ?? 99) - (severityRank[b.severity] ?? 99)
                  ),
                  missingTests: toStringArray(parsed?.missingTests),
                  openQuestions: toStringArray(parsed?.openQuestions)
                };
              } catch {
                return null;
              }
            };

            const collectAddedLines = (patch) => {
              const added = new Set();
              if (!patch) return added;

              let newLine = 0;
              for (const line of patch.split("\n")) {
                const hunk = line.match(/^@@ -\d+(?:,\d+)? \+(\d+)(?:,\d+)? @@/);
                if (hunk) {
                  newLine = Number(hunk[1]);
                  continue;
                }
                if (line.startsWith("+") && !line.startsWith("+++")) {
                  added.add(newLine);
                  newLine += 1;
                  continue;
                }
                if (line.startsWith("-") && !line.startsWith("---")) {
                  continue;
                }
                if (!line.startsWith("\\")) {
                  newLine += 1;
                }
              }
              return added;
            };

            const validAddedLinesByPath = new Map(
              files
                .filter((f) => Boolean(f.patch))
                .map((f) => [f.filename, collectAddedLines(f.patch)])
            );

            const fileSet = new Set(files.map((f) => f.filename));
            const reviewedCommit = pr.data.head.sha;

            const prompt = [
              `너는 CodeRabbit 스타일의 엄격한 시니어 코드 리뷰어다.`,
              `버그/회귀/보안/성능/테스트 누락을 우선하고, 사소한 스타일 논쟁은 제외해라.`,
              `반드시 JSON만 반환해라. 마크다운/설명문 금지.`,
              `JSON 스키마:`,
              `{`,
              `  "findings": [`,
              `    {`,
              `      "severity": "critical|major|minor",`,
              `      "file": "변경 파일 경로",`,
              `      "line": 123,`,
              `      "summary": "한 줄 이슈 요약",`,
              `      "impact": "왜 문제인지",`,
              `      "evidence": "근거",`,
              `      "suggestion": "수정 제안"`,
              `    }`,
              `  ],`,
              `  "missingTests": ["누락 테스트1"],`,
              `  "openQuestions": ["확인 필요 사항1"]`,
              `}`,
              `규칙:`,
              `- finding은 최대 12개`,
              `- 심각도 순서: critical > major > minor`,
              `- line은 가능하면 diff의 추가 라인(+ side) 번호 사용`,
              ``,
              `PR title: ${pr.data.title}`,
              `PR body: ${pr.data.body || "(empty)"}`,
              ``,
              `Diff:`,
              diffText
            ].join("\n");

            const upsertSummaryComment = async (body) => {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: pull_number,
                per_page: 100
              });

              const previous = comments.find((c) => c.body && c.body.includes(marker));
              if (previous) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: previous.id,
                  body
                });
                return previous;
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body
              });
              return null;
            };

            const response = await fetch("https://api.openai.com/v1/responses", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${process.env.OPENAI_API_KEY}`
              },
              body: JSON.stringify({
                model: process.env.OPENAI_MODEL || "gpt-4.1-mini",
                input: prompt
              })
            });

            if (!response.ok) {
              const errText = await response.text();
              if (response.status === 429 && errText.includes("insufficient_quota")) {
                const quotaBody = [
                  marker,
                  "## AI PR Review",
                  "",
                  "AI 리뷰가 건너뛰어졌습니다: OpenAI API 쿼터 초과(`insufficient_quota`).",
                  "OpenAI 결제/쿼터 설정을 확인한 뒤, 새 커밋을 푸시하거나 워크플로우를 다시 실행하세요.",
                  "",
                  `Reviewed commit: \`${reviewedCommit}\``,
                  "",
                  `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
                ].join("\n");

                await upsertSummaryComment(quotaBody);

                core.warning(`OpenAI quota exceeded: ${errText}`);
                return;
              }

              core.setFailed(`OpenAI API error: ${response.status} ${errText}`);
              return;
            }

            const result = await response.json();
            const reviewText = extractReviewText(result);

            if (!reviewText) {
              core.warning(`Empty review payload: ${JSON.stringify(result).slice(0, 1000)}`);
              core.setFailed("OpenAI returned an empty review.");
              return;
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pull_number,
              per_page: 100
            });
            const previous = comments.find((c) => c.body && c.body.includes(marker));
            const alreadyReviewedThisCommit = Boolean(
              previous?.body && previous.body.includes(`Reviewed commit: \`${reviewedCommit}\``)
            );

            const parsed = parseReviewJson(reviewText);

            if (!parsed) {
              const fallbackBody = [
                marker,
                "## AI PR Review",
                "",
                `Reviewed commit: \`${reviewedCommit}\``,
                "",
                reviewText,
                "",
                `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
              ].join("\n");
              await upsertSummaryComment(fallbackBody);
              core.warning("Could not parse JSON review response. Posted raw review text.");
              return;
            }

            const findingsMarkdown =
              parsed.findings.length === 0
                ? ["No blocking findings."]
                : parsed.findings.map((f) =>
                    [
                      `- [severity: ${f.severity}] ${f.file || "(unknown file)"}${
                        f.line ? `:${f.line}` : ""
                      } - ${f.summary}`,
                      `  - 영향: ${f.impact || "영향 분석 누락"}`,
                      `  - 근거: ${f.evidence || "근거 누락"}`,
                      `  - 제안: ${f.suggestion || "제안 누락"}`
                    ].join("\n")
                  );

            const outOfRange = [];
            const inlineComments = [];

            for (const finding of parsed.findings) {
              if (inlineComments.length >= MAX_INLINE_FINDINGS) break;
              if (!finding.file || !fileSet.has(finding.file) || !finding.line) {
                outOfRange.push(finding);
                continue;
              }

              const validLines = validAddedLinesByPath.get(finding.file);
              if (!validLines || !validLines.has(finding.line)) {
                outOfRange.push(finding);
                continue;
              }

              inlineComments.push({
                path: finding.file,
                line: finding.line,
                side: "RIGHT",
                body: [
                  `**[${finding.severity.toUpperCase()}]** ${finding.summary}`,
                  ``,
                  `영향: ${finding.impact || "영향 분석 누락"}`,
                  `근거: ${finding.evidence || "근거 누락"}`,
                  `제안: ${finding.suggestion || "제안 누락"}`
                ].join("\n")
              });
            }

            let inlinePosted = 0;
            if (!alreadyReviewedThisCommit && inlineComments.length > 0) {
              await github.rest.pulls.createReview({
                owner,
                repo,
                pull_number,
                event: "COMMENT",
                commit_id: reviewedCommit,
                body: `AI inline review (${inlineComments.length} findings)`,
                comments: inlineComments
              });
              inlinePosted = inlineComments.length;
            }

            const outOfRangeLines =
              outOfRange.length === 0
                ? []
                : [
                    "",
                    "## Out-of-Diff Findings",
                    ...outOfRange.map((f) =>
                      `- [severity: ${f.severity}] ${f.file || "(unknown file)"}${
                        f.line ? `:${f.line}` : ""
                      } - ${f.summary}`
                    )
                  ];

            const missingTestsLines =
              parsed.missingTests.length === 0 ? ["- 없음"] : parsed.missingTests.map((t) => `- ${t}`);
            const openQuestionsLines =
              parsed.openQuestions.length === 0 ? ["- 없음"] : parsed.openQuestions.map((q) => `- ${q}`);

            const body = [
              marker,
              "## AI PR Review",
              "",
              `Reviewed commit: \`${reviewedCommit}\``,
              `Inline comments posted: ${inlinePosted}`,
              "",
              "## Findings",
              ...findingsMarkdown,
              "",
              "## Missing Tests",
              ...missingTestsLines,
              "",
              "## Open Questions",
              ...openQuestionsLines,
              ...outOfRangeLines,
              "",
              `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
            ].join("\n");

            await upsertSummaryComment(body);
