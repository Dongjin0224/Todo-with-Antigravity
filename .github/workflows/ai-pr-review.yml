name: AI PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  review:
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest

    steps:
      - name: Generate AI review comment
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || secrets.OPENAI_KEY }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4.1-mini' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const marker = "<!-- ai-pr-review -->";
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            if (!process.env.OPENAI_API_KEY) {
              core.setFailed("Missing OPENAI_API_KEY secret.");
              return;
            }

            const pr = await github.rest.pulls.get({ owner, repo, pull_number });
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const diffChunks = files
              .filter((f) => Boolean(f.patch))
              .map((f) => `### ${f.filename}\n\`\`\`diff\n${f.patch}\n\`\`\``);

            if (diffChunks.length === 0) {
              core.info("No patch content to review.");
              return;
            }

            const MAX_DIFF_CHARS = 120000;
            const diffText = diffChunks.join("\n\n").slice(0, MAX_DIFF_CHARS);

            const prompt = [
              `You are a strict senior code reviewer.`,
              `Review this pull request and focus on:`,
              `1) Bugs or logic errors`,
              `2) Security/privacy risks`,
              `3) Behavioral regressions`,
              `4) Missing tests and edge cases`,
              `Return concise markdown in this structure:`,
              `- Critical findings`,
              `- Major findings`,
              `- Minor findings`,
              `- Missing tests`,
              `If none, explicitly say 'No critical issues found.'`,
              ``,
              `PR title: ${pr.data.title}`,
              `PR body: ${pr.data.body || "(empty)"}`,
              ``,
              `Diff:`,
              diffText
            ].join("\n");

            const response = await fetch("https://api.openai.com/v1/responses", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${process.env.OPENAI_API_KEY}`
              },
              body: JSON.stringify({
                model: process.env.OPENAI_MODEL || "gpt-4.1-mini",
                input: prompt
              })
            });

            if (!response.ok) {
              const errText = await response.text();
              // Do not fail the whole PR check for quota/billing issues.
              if (response.status === 429 && errText.includes("insufficient_quota")) {
                const quotaBody = [
                  marker,
                  "## AI PR Review",
                  "",
                  "AI review skipped: OpenAI API quota is exceeded (`insufficient_quota`).",
                  "Check OpenAI billing/quota settings, then push a new commit or re-run this workflow.",
                  "",
                  `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
                ].join("\n");

                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: pull_number,
                  per_page: 100
                });

                const previous = comments.find((c) => c.body && c.body.includes(marker));
                if (previous) {
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: previous.id,
                    body: quotaBody
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pull_number,
                    body: quotaBody
                  });
                }

                core.warning(`OpenAI quota exceeded: ${errText}`);
                return;
              }

              core.setFailed(`OpenAI API error: ${response.status} ${errText}`);
              return;
            }

            const result = await response.json();

            const extractReviewText = (payload) => {
              if (!payload || typeof payload !== "object") return "";
              if (typeof payload.output_text === "string" && payload.output_text.trim()) {
                return payload.output_text.trim();
              }

              const fromOutput = (payload.output || [])
                .flatMap((item) => item.content || [])
                .map((part) => {
                  if (typeof part?.text === "string") return part.text;
                  if (typeof part?.content === "string") return part.content;
                  return "";
                })
                .filter(Boolean)
                .join("\n")
                .trim();
              if (fromOutput) return fromOutput;

              const fromMessage = (payload.choices || [])
                .map((choice) => {
                  const c = choice?.message?.content;
                  if (typeof c === "string") return c;
                  if (Array.isArray(c)) {
                    return c
                      .map((p) => (typeof p?.text === "string" ? p.text : ""))
                      .filter(Boolean)
                      .join("\n");
                  }
                  return "";
                })
                .filter(Boolean)
                .join("\n")
                .trim();
              return fromMessage;
            };

            const reviewText = extractReviewText(result);

            if (!reviewText) {
              core.warning(`Empty review payload: ${JSON.stringify(result).slice(0, 1000)}`);
              core.setFailed("OpenAI returned an empty review.");
              return;
            }

            const body = [
              marker,
              "## AI PR Review",
              "",
              reviewText,
              "",
              `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
            ].join("\n");

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pull_number,
              per_page: 100
            });

            const previous = comments.find((c) => c.body && c.body.includes(marker));

            if (previous) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: previous.id,
                body
              });
              core.info(`Updated existing AI review comment: ${previous.id}`);
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body
              });
              core.info("Created new AI review comment.");
            }
