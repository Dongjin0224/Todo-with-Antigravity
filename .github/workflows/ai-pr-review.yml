name: AI PR Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled]
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  review:
    if: ${{ github.event_name == 'workflow_dispatch' || (!github.event.pull_request.draft && contains(github.event.pull_request.labels.*.name, 'ai-reviw')) }}
    runs-on: ubuntu-latest

    steps:
      - name: Generate AI review comment
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || secrets.OPENAI_KEY }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4.1-mini' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const marker = "<!-- ai-pr-review -->";
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            if (!process.env.OPENAI_API_KEY) {
              core.setFailed("Missing OPENAI_API_KEY secret.");
              return;
            }

            const pr = await github.rest.pulls.get({ owner, repo, pull_number });
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const diffChunks = files
              .filter((f) => Boolean(f.patch))
              .map((f) => `### ${f.filename}\n\`\`\`diff\n${f.patch}\n\`\`\``);

            if (diffChunks.length === 0) {
              core.info("No patch content to review.");
              return;
            }

            const MAX_DIFF_CHARS = 120000;
            const diffText = diffChunks.join("\n\n").slice(0, MAX_DIFF_CHARS);

            const prompt = [
              `너는 엄격한 시니어 코드 리뷰어다.`,
              `아래 Pull Request를 리뷰하고 다음 항목에 집중해라:`,
              `1) 버그 또는 로직 오류`,
              `2) 보안/개인정보 위험`,
              `3) 동작 회귀(기존 기능 깨짐)`,
              `4) 누락된 테스트와 엣지 케이스`,
              `응답은 반드시 한국어 마크다운으로, 아래 구조를 정확히 사용해라:`,
              `- 치명적 이슈`,
              `- 주요 이슈`,
              `- 경미한 이슈`,
              `- 누락된 테스트`,
              `치명적 이슈가 없으면 반드시 '치명적 이슈 없음.'이라고 명시해라.`,
              ``,
              `PR title: ${pr.data.title}`,
              `PR body: ${pr.data.body || "(empty)"}`,
              ``,
              `Diff:`,
              diffText
            ].join("\n");

            const response = await fetch("https://api.openai.com/v1/responses", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${process.env.OPENAI_API_KEY}`
              },
              body: JSON.stringify({
                model: process.env.OPENAI_MODEL || "gpt-4.1-mini",
                input: prompt
              })
            });

            if (!response.ok) {
              const errText = await response.text();
              if (response.status === 429 && errText.includes("insufficient_quota")) {
                const quotaBody = [
                  marker,
                  "## AI PR Review",
                  "",
                  "AI 리뷰가 건너뛰어졌습니다: OpenAI API 쿼터 초과(`insufficient_quota`).",
                  "OpenAI 결제/쿼터 설정을 확인한 뒤, 새 커밋을 푸시하거나 워크플로우를 다시 실행하세요.",
                  "",
                  `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
                ].join("\n");

                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner,
                  repo,
                  issue_number: pull_number,
                  per_page: 100
                });

                const previous = comments.find((c) => c.body && c.body.includes(marker));
                if (previous) {
                  await github.rest.issues.updateComment({
                    owner,
                    repo,
                    comment_id: previous.id,
                    body: quotaBody
                  });
                } else {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pull_number,
                    body: quotaBody
                  });
                }

                core.warning(`OpenAI quota exceeded: ${errText}`);
                return;
              }

              core.setFailed(`OpenAI API error: ${response.status} ${errText}`);
              return;
            }

            const result = await response.json();

            const extractReviewText = (payload) => {
              if (!payload || typeof payload !== "object") return "";
              if (typeof payload.output_text === "string" && payload.output_text.trim()) {
                return payload.output_text.trim();
              }

              const fromOutput = (payload.output || [])
                .flatMap((item) => item.content || [])
                .map((part) => {
                  if (typeof part?.text === "string") return part.text;
                  if (typeof part?.content === "string") return part.content;
                  return "";
                })
                .filter(Boolean)
                .join("\n")
                .trim();
              if (fromOutput) return fromOutput;

              const fromMessage = (payload.choices || [])
                .map((choice) => {
                  const c = choice?.message?.content;
                  if (typeof c === "string") return c;
                  if (Array.isArray(c)) {
                    return c
                      .map((p) => (typeof p?.text === "string" ? p.text : ""))
                      .filter(Boolean)
                      .join("\n");
                  }
                  return "";
                })
                .filter(Boolean)
                .join("\n")
                .trim();
              return fromMessage;
            };

            const reviewText = extractReviewText(result);

            if (!reviewText) {
              core.warning(`Empty review payload: ${JSON.stringify(result).slice(0, 1000)}`);
              core.setFailed("OpenAI returned an empty review.");
              return;
            }

            const body = [
              marker,
              "## AI PR Review",
              "",
              reviewText,
              "",
              `Model: \`${process.env.OPENAI_MODEL || "gpt-4.1-mini"}\``
            ].join("\n");

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pull_number,
              per_page: 100
            });

            const previous = comments.find((c) => c.body && c.body.includes(marker));

            if (previous) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: previous.id,
                body
              });
              core.info(`Updated existing AI review comment: ${previous.id}`);
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body
              });
              core.info("Created new AI review comment.");
            }
