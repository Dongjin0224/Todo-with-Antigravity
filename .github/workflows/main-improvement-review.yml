name: Main Improvement Review

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      base_sha:
        description: "Base commit SHA (optional)"
        required: false
        type: string
      head_sha:
        description: "Head commit SHA (optional)"
        required: false
        type: string

permissions:
  contents: read
  issues: write

jobs:
  review-main-update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Build change context
        id: context
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            BASE_SHA="${{ github.event.inputs.base_sha }}"
            HEAD_SHA="${{ github.event.inputs.head_sha }}"
          else
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
          fi

          if [[ -z "$HEAD_SHA" ]]; then
            HEAD_SHA="$(git rev-parse HEAD)"
          fi

          if [[ -z "$BASE_SHA" || "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
            BASE_SHA="$(git rev-parse "${HEAD_SHA}^" 2>/dev/null || true)"
          fi

          if [[ -z "$BASE_SHA" ]]; then
            echo "No valid base commit. Skip run."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "base_sha=$BASE_SHA" >> "$GITHUB_OUTPUT"
          echo "head_sha=$HEAD_SHA" >> "$GITHUB_OUTPUT"

          git diff --name-only "$BASE_SHA" "$HEAD_SHA" > changed_files.txt
          git diff --unified=2 --no-color "$BASE_SHA" "$HEAD_SHA" > full_diff.patch

          if [[ ! -s changed_files.txt ]]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          MAX_DIFF_CHARS=120000
          DIFF_CHARS="$(wc -c < full_diff.patch)"
          if (( DIFF_CHARS > MAX_DIFF_CHARS )); then
            head -c "$MAX_DIFF_CHARS" full_diff.patch > review_diff.patch
            echo "diff_truncated=true" >> "$GITHUB_OUTPUT"
          else
            cp full_diff.patch review_diff.patch
            echo "diff_truncated=false" >> "$GITHUB_OUTPUT"
          fi
          echo "skip=false" >> "$GITHUB_OUTPUT"

      - name: Generate and post improvement report
        if: steps.context.outputs.skip == 'false'
        uses: actions/github-script@v7
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || secrets.OPENAI_KEY }}
          OPENAI_MODEL: ${{ vars.OPENAI_MODEL || 'gpt-4.1-mini' }}
          ALLOW_SEND_DIFF_TO_OPENAI: ${{ vars.ALLOW_SEND_DIFF_TO_OPENAI || 'false' }}
          BASE_SHA: ${{ steps.context.outputs.base_sha }}
          HEAD_SHA: ${{ steps.context.outputs.head_sha }}
          DIFF_TRUNCATED: ${{ steps.context.outputs.diff_truncated }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require("fs");

            const { owner, repo } = context.repo;
            const baseSha = process.env.BASE_SHA;
            const headSha = process.env.HEAD_SHA;
            const diffTruncated = String(process.env.DIFF_TRUNCATED || "false") === "true";
            const openaiKey = process.env.OPENAI_API_KEY;
            const openaiModel = process.env.OPENAI_MODEL || "gpt-4.1-mini";
            const allowSendDiff =
              String(process.env.ALLOW_SEND_DIFF_TO_OPENAI || "false").toLowerCase() === "true";

            if (!allowSendDiff) {
              core.info("AI 리포트 생략: 외부 diff 분석을 허용하려면 ALLOW_SEND_DIFF_TO_OPENAI=true 를 설정하세요.");
              return;
            }

            if (!openaiKey) {
              core.setFailed("Missing OPENAI_API_KEY secret.");
              return;
            }

            const changedFiles = fs.readFileSync("changed_files.txt", "utf8").trim();
            const diff = fs.readFileSync("review_diff.patch", "utf8").trim();

            if (!changedFiles || !diff) {
              core.info("No change context to review.");
              return;
            }

            const redactSensitive = (text) => {
              if (!text) return text;
              return String(text)
                .replace(/-----BEGIN [A-Z ]*PRIVATE KEY-----[\s\S]*?-----END [A-Z ]*PRIVATE KEY-----/g, "[REDACTED_PRIVATE_KEY]")
                .replace(/(api[_-]?key|secret|token|password|passwd)\s*[:=]\s*["']?([^\s"'`]+)/gi, "$1=[REDACTED]")
                .replace(/\b(AKIA[0-9A-Z]{16})\b/g, "[REDACTED_AWS_ACCESS_KEY]")
                .replace(/\b(ghp_[A-Za-z0-9]{20,})\b/g, "[REDACTED_GITHUB_TOKEN]")
                .replace(/\b(sk-[A-Za-z0-9]{20,})\b/g, "[REDACTED_OPENAI_KEY]");
            };

            const sanitizedChangedFiles = redactSensitive(changedFiles);
            const sanitizedDiff = redactSensitive(diff);

            const prompt = [
              "You are a pragmatic senior product+engineering reviewer.",
              "Your task: review ONLY the changed code and suggest project improvements.",
              "Focus on:",
              "1) Features to add",
              "2) Features/behaviors to simplify or remove",
              "3) UX/dev-experience/maintainability improvements",
              "4) Technical debt priorities",
              "",
              "Output rules:",
              "- Write in Korean.",
              "- Use markdown.",
              "- Be concrete and actionable.",
              "- Prioritize impact and effort.",
              "- Do not repeat raw diff.",
              "",
              "Required sections:",
              "## Summary",
              "## Add (High Value Features)",
              "## Remove or Simplify",
              "## Improve (Architecture/Quality/UX)",
              "## Next 3 Actions",
              "",
              `Changed files:\n${sanitizedChangedFiles}`,
              "",
              "Diff:",
              sanitizedDiff
            ].join("\n");

            const response = await fetch("https://api.openai.com/v1/responses", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${openaiKey}`
              },
              body: JSON.stringify({
                model: openaiModel,
                input: prompt
              })
            });

            if (!response.ok) {
              const errText = await response.text();
              core.setFailed(`OpenAI API error: ${response.status} ${errText}`);
              return;
            }

            const payload = await response.json();
            const report = (payload.output || [])
              .flatMap((item) => (Array.isArray(item?.content) ? item.content : []))
              .filter((part) => part?.type === "output_text" && typeof part?.text === "string")
              .map((part) => part.text)
              .join("\n")
              .trim();
            if (!report) {
              core.setFailed("OpenAI returned an empty report.");
              return;
            }

            const hubMarker = "<!-- main-improvement-hub -->";
            const commitMarker = `<!-- main-improvement:${headSha} -->`;
            const issueTitle = "메인 업데이트 개선 제안";
            const legacyIssueTitles = [
              "메인 업데이트 개선 제안 허브",
              "메인 브랜치 개선 리뷰",
              "Main Branch Improvement Review"
            ];

            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: "open",
              per_page: 100
            });

            let hub = issues.find(
              (i) => !i.pull_request && (i.body || "").includes(hubMarker)
            );

            if (!hub) {
              hub = issues.find(
                (i) =>
                  !i.pull_request &&
                  (i.title === issueTitle || legacyIssueTitles.includes(i.title))
              );
            }

            if (!hub) {
              const created = await github.rest.issues.create({
                owner,
                repo,
                title: issueTitle,
                body: [
                  hubMarker,
                  "이 이슈는 `main` 업데이트마다 자동 생성된 개선 리포트를 누적합니다.",
                  "",
                  "- 소스: `.github/workflows/main-improvement-review.yml`",
                  "- 범위: 보안 전용이 아닌 기능 추가/제거/단순화/품질 개선 제안"
                ].join("\n")
              });
              hub = created.data;
            }

            const hubComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: hub.number,
              per_page: 100
            });

            if (hubComments.some((c) => (c.body || "").includes(commitMarker))) {
              core.info(`${headSha} 커밋에 대한 리포트가 이미 존재합니다.`);
              return;
            }

            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${context.runId}`;
            const shortHead = headSha.slice(0, 7);
            const shortBase = baseSha.slice(0, 7);

            const body = [
              commitMarker,
              `## 메인 업데이트 리뷰 (${shortBase} -> ${shortHead})`,
              "",
              `- 기준 커밋(Base): \`${baseSha}\``,
              `- 대상 커밋(Head): \`${headSha}\``,
              `- Diff 잘림 여부: \`${diffTruncated}\``,
              `- 워크플로우 실행: ${runUrl}`,
              "",
              report
            ].join("\n");

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: hub.number,
              body
            });
